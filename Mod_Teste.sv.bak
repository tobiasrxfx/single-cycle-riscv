`default_nettype none //Comando para desabilitar declaração automática de wires
module Mod_Teste (
//Clocks
input CLOCK_27, CLOCK_50,
//Chaves e Botoes
input [3:0] KEY,
input [17:0] SW,
//Displays de 7 seg e LEDs
output [0:6] HEX0, HEX1, HEX2, HEX3, HEX4, HEX5, HEX6, HEX7,
output [8:0] LEDG,
output [17:0] LEDR,
//Serial
output UART_TXD,
input UART_RXD,
inout [7:0] LCD_DATA,
output LCD_ON, LCD_BLON, LCD_RW, LCD_EN, LCD_RS,
//GPIO
inout [35:0] GPIO_0, GPIO_1
);
assign GPIO_1 = 36'hzzzzzzzzz;
assign GPIO_0 = 36'hzzzzzzzzz;
assign LCD_ON = 1'b1;
assign LCD_BLON = 1'b1;
logic [7:0] w_d0x0, w_d0x1, w_d0x2, w_d0x3, w_d0x4, w_d0x5,
w_d1x0, w_d1x1, w_d1x2, w_d1x3, w_d1x4, w_d1x5;
LCD_TEST MyLCD (
.iCLK ( CLOCK_50 ),
.iRST_N ( KEY[0] ),
.d0x0(w_d0x0),.d0x1(w_d0x1),.d0x2(w_d0x2),.d0x3(w_d0x3),.d0x4(w_d0x4),.d0x5(w_d0x5),
.d1x0(w_d1x0),.d1x1(w_d1x1),.d1x2(w_d1x2),.d1x3(w_d1x3),.d1x4(w_d1x4),.d1x5(w_d1x5),
.LCD_DATA( LCD_DATA ),
.LCD_RW ( LCD_RW ),
.LCD_EN ( LCD_EN ),
.LCD_RS ( LCD_RS )
);
//---------- modifique a partir daqui --------

// assign HEX0[0:6] = SW[6:0];

//decoder_hexseven decoder_uut(.a(SW[11:8]), .out(HEX3[0:6]));

logic clk_1hz; 
logic [3:0] contador;

//clk_divider clk_divider_uut (.clk_in(CLOCK_50), .clk_out(clk_1hz));

// mod_counter mod_counter_uut (.clk(clk_1hz), .rst(KEY[1]), .count(contador));

//animation animation_uut (.clk(clk_1hz), .disp_0(HEX3), .disp_1(HEX2), .disp_2(HEX1), .disp_3(HEX0));


logic [7:0] w_rd2, w_rd1SrcA, w_SrcB; 


assign w_d0x0 = w_rd1SrcA;
assign w_d1x0 = w_rd2;
assign w_d1x1 = w_SrcB;				
				
logic [7:0] w_PC;
logic [31:0] w_Inst; 
logic [7:0] w_PCp4, w_ULAResult;
logic w_RegWrite, w_ULASrc; 
logic [2:0] w_ULAControl; 

logic [7:0] w_debug_reg_out [0:7];

// ROM 
logic [31:0] rom [0:255]; 

//$readmemh("hexprog.txt", rom);

assign w_Inst = rom[w_PC]; // Instruction memory 

assign w_PCp4 = w_PC + 4; // Get the next instruction ** Moves PC 

program_counter pc_uut(.pc_in(w_PCp4), 
                       .clk(KEY[1]), 
                       .rst(KEY[3]), 
                       .pc_out(w_PC)); 
							  
control_unit ctrl_unit_uut(.op(w_Inst[6:0]),
                           .funct3(w_Inst[14:12]),
									.funct7(w_Inst[31:25]),
									.ula_control(w_ULAControl),
									.ula_src(w_ULASrc),
									.reg_write(w_RegWrite));
									
register_file reg_file_uut(.write_data(w_ULAResult),
									.write_addr(w_Inst[11:7]),
									.write_enable(w_RegWrite),
									.read_addr0(w_Inst[19:15]), 
									.read_addr1(w_Inst[24:20]),
									.clk(KEY[1]), 
									.rst(KEY[3]),
									.reg_data0(w_rd1SrcA),
									.reg_data1(w_rd2),
									.debug_reg_out(w_debug_reg_out)
									); 

ula ula_uut(.src_a(w_rd1SrcA),
			   .src_b(w_SrcB),
				.ctrl(w_ULAControl),
				.result(w_ULAResult),
				.zero(LEDG[0]));
				
mux_2x1 mux_uut(.a(w_rd2),
					 .b(w_Inst[27:20]), // Instead of [31:20], think about upgrade!
					 .select(w_ULASrc),
					 .c(w_SrcB));
					 
					 
// Ligacoes auxiliares 

assign w_d0x0 = w_debug_reg_out[0];
assign w_d0x1 = w_debug_reg_out[1];
assign w_d0x2 = w_debug_reg_out[2];
assign w_d0x3 = w_debug_reg_out[3];
assign w_d1x0 = w_debug_reg_out[4];
assign w_d1x1 = w_debug_reg_out[5];
assign w_d1x2 = w_debug_reg_out[6];
assign w_d1x3 = w_debug_reg_out[7];

assign w_d0x4 = w_PC;

decoder_hexseven decoder_uut(.a(w_Inst[3:0]), .out(HEX0[0:6]));
decoder_hexseven decoder_uut2(.a(w_Inst[7:4]), .out(HEX1[0:6]));
decoder_hexseven decoder_uut3(.a(w_Inst[11:8]), .out(HEX2[0:6]));
decoder_hexseven decoder_uut4(.a(w_Inst[15:12]), .out(HEX3[0:6]));
decoder_hexseven decoder_uut5(.a(w_Inst[19:16]), .out(HEX4[0:6]));
decoder_hexseven decoder_uut6(.a(w_Inst[23:20]), .out(HEX5[0:6]));
decoder_hexseven decoder_uut7(.a(w_Inst[27:24]), .out(HEX6[0:6]));
decoder_hexseven decoder_uut8(.a(w_Inst[31:28]), .out(HEX7[0:6]));

assign LED[2:0] = w_ULAControl;
assign LED[3] = w_ULASrc;
assign LED[4] = w_RegWrite;

endmodule
